#!/usr/bin/octave -qfif (nargin!=1)printf("Usage: multinomial.m <data_filename>");exit(1);endarglist=argv();datafile=arglist{1};disp("Loading data...");load(datafile);disp("Data load complete.");[nrows,ncols]=size(tr);#rand("seed",23); #perm=randperm(nrows);#pdata=data(perm,:); #utilizamos los indices  para sacar la permutacion de los datos#trper=0.9;#ntr=floor(nrows*trper); #numero de muestras train#nte=nrows-ntr; #numero de muestras test#tr=pdata(1:ntr,:);  #traintrData = tr(:,1:ncols-1); #matriz trainDatatrData = trData > 0;trLabels = tr(:,ncols); #vector de clases trainingHam = find(trLabels ==  0);  #vectores HAMSpam = find(trLabels ==  1); #vectores SPAM#te=pdata(ntr+1:end,:); #testtestData = te(:,1:ncols-1); #matriz testDatatestData = testData >0;testLabels = te(:,ncols); #vector de clases test#Calculamos las prioris realizando un conteoPrioriHam = length(Ham)/length(trLabels); PrioriSpam = length(Spam)/length(trLabels);sumDataHam = sum(trData(Ham,:));pHamOriginal = sumDataHam / length(Ham); #prototipo de HAMsumDataSpam = sum(trData(Spam,:)); pSpamOriginal = sumDataSpam / length(Spam); #Prototipo de SPAMfor i = 0:0.0001:0.4  #suavizado pHam y pSpam con truncamiento simple  e = i;  pHam = (pHamOriginal<e) * e + (pHamOriginal>(1-e))*(1-e)+ (pHamOriginal>=e & pHamOriginal<=(1-e)) .*pHamOriginal;  pSpam = (pSpamOriginal<e) * e + (pSpamOriginal>(1-e))*(1-e)+ (pSpamOriginal>=e & pSpamOriginal<=(1-e)) .*pSpamOriginal;  gH = (log(pHam)-log(1-pHam))*testData' +log(PrioriHam)+sum(log(1-pHam));  gS = (log(pSpam)-log(1-pSpam))*testData' +log(PrioriSpam)+sum(log(1-pSpam));  t = gH < gS;  correct = testLabels == t';  error = sum(correct==1)/numel(testLabels);  printf("epsilon: %.20f \t  error: %.3f \n",e,1-error) endfor