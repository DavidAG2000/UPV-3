#!/usr/bin/octave -qfif (nargin!=1)printf("Usage: multinomial.m <data_filename>");exit(1);endarglist=argv();datafile=arglist{1};disp("Loading data...");load(datafile);disp("Data load complete.");[nrows,ncols]=size(data);matrix_particiones = zeros(30,20);rand("seed",23); for j = 1:30  perm=randperm(nrows);  pdata=data(perm,:); #utilizamos los indices  para sacar la permutacion de los datos  trper=0.9;  ntr=floor(nrows*trper); #numero de muestras train  nte=nrows-ntr; #numero de muestras test  tr=pdata(1:ntr,:);  #train  trData = tr(:,1:ncols-1); #matriz trainData  trLabels = tr(:,ncols); #vector de clases training  Ham = find(trLabels ==  0);  #vectores HAM  Spam = find(trLabels ==  1); #vectores SPAM  te=pdata(ntr+1:end,:); #test  testData = te(:,1:ncols-1); #matriz testData  testLabels = te(:,ncols); #vector de clases test  #Calculamos las prioris realizando un conteo  PrioriHam = length(Ham)/length(trLabels);   PrioriSpam = length(Spam)/length(trLabels);  sumDataHam = sum(sum(trData(Ham,:)));  pHamOriginal = sum(trData(Ham,:)) / sumDataHam; #prototipo de HAM  sumDataSpam = sum(sum(trData(Spam,:)));   pSpamOriginal = sum(trData(Spam,:)) / sumDataSpam; #Prototipo de SPAM  for i = 1:20    #suavizado pHam    e = 10^-i;    pHam = pHamOriginal+e;    pHam = pHam / sum(pHam);    pSpam = pSpamOriginal+e;    pSpam = pSpam / sum(pSpam);    gH = log(pHam)*testData' +log(PrioriHam);    gS = log(pSpam)*testData' +log(PrioriSpam);    t = gH < gS;    correct = testLabels == t';    error = sum(correct==1)/numel(testLabels);    matrix_particiones(j,i) = 1-error;    endforendfor vectormean = mean(matrix_particiones,1); vectorstd = std(matrix_particiones,1); for i = 1:20printf("%.20f \t %.3f \t %.3f\n",10^-i,vectormean(i),2*vectorstd(i)); endfor